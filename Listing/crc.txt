; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\..\output\crc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\crc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\Alogrisem\inc -I..\..\User\BSP_Init\inc -I..\..\User\exDev\inc -IH:\CETC\Project\第二代机器鱼程序\AV1.3\Project\RVMDK（uv4）\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -W --omf_browse=..\..\output\crc.crf ..\..\User\Alogrisem\src\CRC.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  checkCRC PROC
;;;13     
;;;14     int checkCRC(int chCurrByte, int chNextByte)
000000  460a              MOV      r2,r1
;;;15     {
;;;16     	int nMask;
;;;17     // CRC循环：每次调用进行8次循环，处理一个字节的数据。
;;;18     	for(nMask = 0x80; nMask > 0; nMask = nMask>>1)
000002  2180              MOVS     r1,#0x80
000004  e012              B        |L1.44|
                  |L1.6|
;;;19     	{
;;;20        		if ((chCurrByte & 0x80) != 0)   // 首位为1：移位，并进行异或运算  
000006  f0000380          AND      r3,r0,#0x80
00000a  b143              CBZ      r3,|L1.30|
;;;21       		{ 
;;;22         		chCurrByte <<= 1;     // 移一位
00000c  0040              LSLS     r0,r0,#1
;;;23         		if ( (chNextByte & nMask) != 0) // 补一位
00000e  ea020301          AND      r3,r2,r1
000012  b10b              CBZ      r3,|L1.24|
;;;24         		{
;;;25          			chCurrByte |= 1;
000014  f0400001          ORR      r0,r0,#1
                  |L1.24|
;;;26         		}	
;;;27         		chCurrByte ^= 7;     // 首位已经移出，仅对低8位进行异或运算，7的二进制为0000,0111
000018  f0800007          EOR      r0,r0,#7
00001c  e005              B        |L1.42|
                  |L1.30|
;;;28        		}
;;;29        		else         // 首位为0，只移位，不进行异或运算
;;;30        		{  
;;;31         		chCurrByte <<= 1;     // 移一位
00001e  0040              LSLS     r0,r0,#1
;;;32         		if ( (chNextByte & nMask) != 0) // 补一位
000020  ea020301          AND      r3,r2,r1
000024  b10b              CBZ      r3,|L1.42|
;;;33         		{
;;;34          			chCurrByte |= 1;
000026  f0400001          ORR      r0,r0,#1
                  |L1.42|
00002a  1049              ASRS     r1,r1,#1              ;18
                  |L1.44|
00002c  2900              CMP      r1,#0                 ;18
00002e  dcea              BGT      |L1.6|
;;;35         		}
;;;36        		}
;;;37     	}
;;;38     	return chCurrByte;
;;;39     }
000030  4770              BX       lr
                          ENDP

